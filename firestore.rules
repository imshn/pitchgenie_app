rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Plans (Read-only for authenticated users)
    match /plans/{planId} {
      allow read: if request.auth != null;
    }

    // Workspaces
    match /workspaces/{workspaceId} {
      // Allow read if user is in memberIds
      // Note: memberIds is an array of strings (UIDs)
      // Allow read if user is in memberIds or is owner
      allow read: if request.auth != null && (
        resource.data.ownerUid == request.auth.uid ||
        ("memberIds" in resource.data && resource.data.memberIds.hasAny([request.auth.uid]))
      );
      
      // Allow create (anyone can create a workspace)
      allow create: if request.auth != null;
      
      // Allow update if owner OR if member updating only allowed fields
      allow update: if request.auth != null && (
        resource.data.ownerUid == request.auth.uid ||
        (resource.data.memberIds.hasAny([request.auth.uid]) && 
         onlyUpdatingAllowedFields())
      );
      
      // Helper function for allowed field updates
      function onlyUpdatingAllowedFields() {
        let allowedFields = ['workspaceName', 'updatedAt'];
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
      }
      
      // Subcollections
      match /leads/{leadId} {
        allow read, write: if request.auth != null && 
          get(/databases/$(database)/documents/workspaces/$(workspaceId)).data.memberIds.hasAny([request.auth.uid]);
      }
      
      match /events/{eventId} {
        allow read: if request.auth != null && 
          get(/databases/$(database)/documents/workspaces/$(workspaceId)).data.memberIds.hasAny([request.auth.uid]);
          
        // Allow write only if user is member (for client-side logging if needed, though mostly server-side)
        allow create: if request.auth != null && 
          get(/databases/$(database)/documents/workspaces/$(workspaceId)).data.memberIds.hasAny([request.auth.uid]);
      }
      
      match /analytics/{docId} {
         allow read: if request.auth != null && 
          get(/databases/$(database)/documents/workspaces/$(workspaceId)).data.memberIds.hasAny([request.auth.uid]);
      }

      // Usage Subcollection (Read-only for members, written by backend)
      match /usage/{monthId} {
        allow read: if request.auth != null && 
          get(/databases/$(database)/documents/workspaces/$(workspaceId)).data.memberIds.hasAny([request.auth.uid]);
      }
    }

    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      match /notifications/{notificationId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Profile Subcollection
      match /profile/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Usage Subcollection (V2 - monthly usage tracking)
      match /usage/{monthId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        // Write is typically done by server, but allow for client-side updates if needed
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      // SMTP Daily Subcollection (V2 - daily SMTP tracking)
      match /smtpDaily/{dateId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        // Write is typically done by server
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      // Other user subcollections (emails sent, events, etc.)
      match /{subcollection}/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
  }
}
